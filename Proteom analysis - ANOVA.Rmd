---
title: "Proteomics analysis (based on normalized intensity)"
author: "Siyu Sun"
date: "5/4/2020"
output: 
  html_document:
    keep_md: true
---

## Chrunks

  * [Load libraries]
  * [Read in pre-processed protein table]
* [One-way ANOVA]
* [WGCNA]
  * [WT -Carbon]
  * [rim15 -Carbon]
  * [WT -Pi]
  * [rim15KO -Pi]
  * [Consensus motif in -C and -Pi for WT]
  * [Consensus motif in -C and -Pi for rim15]

## Load libraries
```{r, include = FALSE, echo = FALSE, message = FALSE, warning=FALSE}
library(dplyr)
library(ggplot2)
library(reshape2)
library(tidyverse)
library(GGally)
library(ggpubr)
library(ggrepel)
library(gridExtra)
library(devtools)
library(ggfortify)
library(limma)
library(gplots)
library(broom)
library(qvalue)
library(pheatmap)
library(RColorBrewer)
library(WGCNA)
#libraries need for GO term analysis
if (!requireNamespace("BiocManager", quietly = TRUE))
#install.packages("BiocManager")
#BiocManager::install("org.Sc.sgd.db")
#BiocManager::install("clusterProfiler")
#library(AnnotationDbi)
library(org.Sc.sgd.db)
library(clusterProfiler)
```
 
## Read in pre-processed protein table
```{r , cache=FALSE, echo = FALSE, message = FALSE, warning=FALSE}
#read in protein groups 
master <- read_csv("./tables/master_protein.csv")

all_matched <- master %>%
  filter(genotype != "spike-in") %>%
  filter(nutrient != "N") %>%
  melt() %>%
  dplyr::select(-variable) %>%
  #remove na values
  dplyr::filter(!is.na(value)) %>% 
  #remove infinite values
  dplyr::filter(is.finite(value)) %>% 
  #remove 0 values, wich will be a problem for later log based transformation
  dplyr::filter(value > 0) %>%
  group_by(`Protein IDs`,`Gene names`, nutrient, samplingTime, genotype, data) %>%
  mutate(rep_numner = n()) %>%
  filter(rep_numner == 3) %>%
  group_by(`Protein IDs`,`Gene names`, nutrient, replicate, genotype, data) %>%
  mutate(time_number = n()) %>%
  filter(time_number == 4)
```

## One-way ANOVA
```{r, cache=FALSE, echo = FALSE, message = FALSE, warning=FALSE}
#pairwise anova analysis
#drop na function
delete.na <- function(DF, n=0) {DF[rowSums(is.na(DF)) <= n,]}

#t-test between genotypes 
pG_reshape <- all_matched %>% 
  group_by(`Protein IDs`, `Protein names`,`Gene names`,`Fasta headers`, data, nutrient, samplingTime) %>%
  unite(cond, genotype, replicate) %>%
  spread(key = cond, value = value) 

#remove the rows whoes has more than 2 NA values
pG_filtered <- delete.na(pG_reshape,2)
  
#run anova test and caculate the mean difference between timepoints for each protein
anova_pG <- pG_filtered %>%
  dplyr::filter(data %in% c("normed_intensity","normed_ratio")) %>%
  melt() %>%
  separate(variable, c("genotype","replicate")) %>%
  group_by(`Protein IDs`, `Protein names`,`Gene names`,`Fasta headers`, nutrient, genotype, data) %>%
  #caculate the log2FC based on estimated mean diff between two groups 
  do(tidy(TukeyHSD(aov(log2(value)~samplingTime, .)))) %>%
  drop_na()

sig_DE <- anova_pG %>% 
  dplyr::rename(log2FC = estimate) %>%
  filter(adj.p.value < 0.1)

write_csv(sig_DE, "./WGCNA/sig_DE_anova_FDR0.1.csv")

summary <-sig_DE %>% group_by(nutrient, genotype, contrast,data) %>%
  summarize(`sig_DE` = n())

print(summary)
```

## WGCNA

### WT -carbon
### choose the soft threshold
```{r, echo = FALSE, message = FALSE, warning=FALSE}
sig_DE <- read_csv("./WGCNA/sig_DE_anova.csv")
proteinData = read_csv("./WGCNA/master_protein.csv")

nutri= "C"
gt = "WT"
dt = "normed_ratio"
tmp <- sig_DE %>% filter(nutrient == nutri & genotype == gt & data == dt)

#prepare expression data table
tmp2 = proteinData %>% filter(data == dt & nutrient == nutri & genotype == gt) %>% 
  filter(`Protein IDs` %in% unique(tmp$`Protein IDs`)) %>% 
  dplyr::select(`Protein IDs`,nutrient, genotype, value, samplingTime, replicate) %>%
  unite(cond, nutrient, genotype, samplingTime, replicate) %>%
  spread(key = cond, value = value)

datExpr0 = log2(as.data.frame(t(tmp2[, -1])))
names(datExpr0) = tmp2$`Protein IDs`

dim(datExpr0)

gsg = goodSamplesGenes(datExpr0, verbose = 3);
gsg$allOK

sampleTree = hclust(dist(datExpr0), method = "average");
# Plot the sample tree: Open a graphic output window of size 12 by 9 inches
# The user should change the dimensions if the window is too large or too small.
sizeGrWindow(12,9)
#pdf(file = "Plots/sampleClustering.pdf", width = 12, height = 9);
par(cex = 0.6);
par(mar = c(0,4,2,0))
plot(sampleTree, main = "Sample clustering to detect outliers", sub="", xlab="", cex.lab = 1.5, 
     cex.axis = 1.5, cex.main = 2)

#Deal with metadata
metaData =
  as.data.frame(rownames(datExpr0)) %>%
  dplyr::rename(cond = `rownames(datExpr0)`) %>%
  separate(cond, c("nutrient","genotype","time","replicate"), remove = FALSE) %>%
  #convert samplingTime to numerics
  dplyr::select(-replicate) %>%
  mutate(time = substr(time, 2, nchar(time))) %>%
  mutate(time = as.numeric(time)) %>%
  data.frame()
  #convert nutrient, genotype into binary attributes

#select the soft-thresholding for co-expression analysis
datExpr = datExpr0 
# Choose a set of soft-thresholding powers
powers = c(c(1:10), seq(from = 12, to=30, by=2))

# Call the network topology analysis function
sft = pickSoftThreshold(datExpr, powerVector = powers, verbose = 5)
# Plot the results:
sizeGrWindow(9, 5)
par(mfrow = c(1,2));
# Scale-free topology fit index as a function of the soft-thresholding power
plot(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
     xlab="Soft Threshold (power)",ylab="Scale Free Topology Model Fit,signed R^2",type="n",
     main = paste("Scale independence"));
text(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
     labels=powers,cex=0.85,col="red");
# this line corresponds to using an R^2 cut-off of h
abline(h=0.85,col="red")
# Mean connectivity as a function of the soft-thresholding power
plot(sft$fitIndices[,1], sft$fitIndices[,5],
     xlab="Soft Threshold (power)",ylab="Mean Connectivity", type="n",
     main = paste("Mean connectivity"))
text(sft$fitIndices[,1], sft$fitIndices[,5], labels=powers, cex=0.85,col="red")
```

### one-step network construction and module detection
```{r, echo = FALSE, message = FALSE, eval = FALSE, warning=FALSE}
softPower = 20
#mergeCutHeight = 0.25
bwnet = blockwiseModules(datExpr, power = softPower, #corType = "biweight",
                       TOMType = "unsigned", minModuleSize = 5,
                       reassignThreshold = 0, mergeCutHeight = 0.25,
                       numericLabels = TRUE, pamRespectsDendro = FALSE,
                       saveTOMs = TRUE,
                       saveTOMFileBase = paste0("filtered_TOM_ratio",nutri,gt), 
                       verbose = 3)

#bwnet$colors
# open a graphics window
sizeGrWindow(12, 9)

moduleLabels = bwnet$colors
moduleColors = labels2colors(bwnet$colors)
MEs = bwnet$MEs;
geneTree = bwnet$dendrograms[[1]];
save(MEs, moduleLabels, moduleColors, geneTree, 
     file = paste0(nutri,"_",gt,"_ratio_networkConstruction-auto.RData"))
```

### Kegg annotation and visualization
```{r, echo = FALSE, message = FALSE, warning=FALSE}
#load saved co-expression clusters.
load(paste0(nutri,"_",gt,"_ratio_networkConstruction-auto.RData"))

table <- as.data.frame(moduleLabels) 
table$`Protein IDs`<- names(moduleLabels)

genotype_col<- c("#ffbc00","#7fd3cf")
names(genotype_col) <- c("WT","rim15KO")
nutrient_col <- c("#c99d4b", "#9343fa")
names(nutrient_col) <- c("C","P")
time_col <- c("#ffdbde","#fc9aa2","#fa4b59","#bd000f")
names(time_col) <- c("T00","T06","T16","T30")
rep_col <- c("#bae6c8","#44c76d","#016320")
names(rep_col) <- c("R1","R2","R3")
anno_colors <- list(nutrient = nutrient_col, genotype = genotype_col, time = time_col, replicate = rep_col)
breaksList = seq(-0.07, 0.07, by = 0.0001)

annotation <- data.frame(rownames(MEs)) %>% separate(`rownames.MEs.`, c("nutrient", "genotype", "time", "replicate"))
rownames(annotation) <- rownames(MEs)
#make heatmaps
pdf(paste0("./ME_",nutri,"_",gt,"_ratio.pdf"), width = 4, height =5)
#remove module 0 which has unsigned genes
mes <- MEs #%>% dplyr::select(-`ME0`)
pheatmap(mes, #labels_row = F,
         colorRampPalette(rev(brewer.pal(n =10, name = "RdBu")))(length(breaksList)),
         cluster_rows=T, cluster_cols=T, annotation_row= annotation, annotation_colors = anno_colors)#, 
          # annotation_col = annotation_col, main = paste0("Log2(",i,")"))
dev.off()

## Quantify traits-module association
nSamples = nrow(datExpr)
# Recalculate MEs with color labels
MEs0 = moduleEigengenes(datExpr, moduleLabels)$eigengenes
MEs = orderMEs(MEs0)
#caculate the correlation between trait time and the expression modules
moduleTraitCor = cor(MEs, metaData[,-c(1:3)], use = "p")
print(moduleTraitCor)
moduleTraitPvalue = corPvalueStudent(moduleTraitCor, nSamples)
#caculate the module membership and plot that in dynamics
geneModuleMembership = as.data.frame(cor(datExpr, MEs, use = "p"))

sizeGrWindow(10,6)
# Will display correlations and their p-values
textMatrix = paste(signif(moduleTraitCor, 2), "\n(", signif(moduleTraitPvalue, 1), ")", sep = "")
dim(textMatrix) = dim(moduleTraitCor)

### kegg annotation of interesting modules 
keggGO <- list()
keggGOresults <- list()
enrichGO <- list()
enrichGOresults <- list()

tb = NULL
tb_pos = NULL
cor_thresh = 0.7
geneModuleMembership = as.data.frame(cor(datExpr, MEs, use = "p"))
ModuleMembership_pos <- geneModuleMembership %>% mutate(`Protein IDs` = rownames(geneModuleMembership)) %>%
  melt() %>%
  #dplyr::rename(modules = variable) %>%
  #remove the ME in each module label
  dplyr::mutate(moduleLabels = substr(variable, 3, nchar(as.character(variable)))) %>% 
  dplyr::rename(Membership = value) %>%
  mutate(moduleLabels = as.numeric(moduleLabels)) %>%
  #remove genes with module membership correlation less than 0.5
  dplyr::filter(Membership > cor_thresh)

for (module in unique(moduleLabels)){
  # Select module probes
  modGenes = (moduleLabels==module)
  pass_filtered = ModuleMembership_pos %>% filter(moduleLabels ==module)
  #separate the columns who has multiple protein IDs in one
  # Get their entrez ID codes
  modLLIDs = datExpr[modGenes]
  modLLIDs$cond <- rownames(modLLIDs)
  passmod <- modLLIDs %>% melt() %>%
    dplyr::rename(`Protein IDs` = variable) %>% 
    filter(`Protein IDs` %in% pass_filtered$`Protein IDs`)
  tb = rbind(tb, data.frame(module,dim(modLLIDs)[2]))
  tb_pos = rbind(tb_pos, data.frame(module,dim(passmod)[2]))
  tmp<-bitr(unique(passmod$`Protein IDs`), "UNIPROT", "ENSEMBL", "org.Sc.sgd.db", drop = TRUE)
  keggGO[[module+1]] <- clusterProfiler::enrichKEGG(gene = tmp$ENSEMBL,
                 organism     = 'sce',
                 pvalueCutoff = 0.05)
      
  enrichGO[[module+1]] <- clusterProfiler::enrichGO(gene = tmp$UNIPROT,
                universe      = names(datExpr),
                ont = "BP",
                keyType = "UNIPROT", 
                 OrgDb     = org.Sc.sgd.db,
                 pvalueCutoff = 0.05)   
   
  keggGOresults[[module+1]] <- keggGO[[module+1]]@result %>% 
        as_tibble() %>% 
        mutate(module=module)
  
  enrichGOresults[[module+1]] <- enrichGO[[module+1]]@result %>% 
        as_tibble() %>% 
        mutate(module=module)
  }

keggGOtable <- bind_rows(keggGOresults) %>% as_tibble 
#  mutate(module=module-1)
 # filter(p.adjust < 0.1)
  
enrichGOtable <- bind_rows(enrichGOresults) %>% as_tibble %>%
  mutate(module=module-1)
 # filter(Count > 1) %>%
 # filter(p.adjust < 0.1)

#write_csv(keggGOtable, "kegg_GO_ratio_modules.csv")
#write_csv(enrichGOtable, "enrich_GO_ratio_modules.csv")

### plot KeggGO terms 
n_count = 1
tmp <- keggGOtable %>% 
  filter (module !=0) %>% 
  #remove the GO terms whose genes counts is less than 4
  filter(Count > n_count) %>%
  dplyr::select(Description, p.adjust, module) %>%
  #dplyr::filter(p.adjust < 0.05) %>% 
  spread(key = "module", value = "p.adjust") 
  

breaks <- seq(min(-log10(keggGOtable$p.adjust)), max(-log10(keggGOtable$p.adjust)), length.out = 101)
my_palette <- my_palette <- colorRampPalette(c("#ccdaff", "#002487")) (n=100)

df <- tmp[,-1]
#replace na values with 0
df[is.na(df)] <- 1
df <- -log10(df)
df[df == 0] <- NA
rownames(df) <- tmp$Description
order <- order(df[, "2"],df[,"1"])
tmp2<-df[order, c(1:2)]
#
pdf(file=paste0("kegg_map_",nutri,"_",gt,"_","ratio(n>",n_count,").pdf"),width = 7, height =6)
heatmap.2(as.matrix(tmp2), Rowv = FALSE, Colv=FALSE,trace="none", na.color = "white", scale="none", col = my_palette, breaks=breaks,margins = c(2,26),cexRow=0.7,cexCol=1,keysize=1.3,sepcolor="grey", sepwidth=c(0.05,0.05),colsep=1:ncol(tmp2),
           rowsep=1:nrow(tmp2))
dev.off()

### plot proteins behavior in each module per condition and 

#get the geneModuleMembership from previous caculation & reshape the dt to combine with the mean expression table
##or you can recalculate its here
geneModuleMembership = as.data.frame(cor(datExpr, MEs, use = "p"))

ModuleMembership <- geneModuleMembership %>% mutate(`Protein IDs` = rownames(geneModuleMembership)) %>%
  melt() %>%
  #dplyr::rename(modules = variable) %>%
  #remove the ME in each module label
  dplyr::mutate(moduleLabels = substr(variable, 3, nchar(as.character(variable)))) %>% 
  dplyr::rename(Membership = value) %>%
  mutate(moduleLabels = as.numeric(moduleLabels))

dataf = NULL
dataf_pos = NULL

for (module in unique(moduleLabels)){
  # Select module probes
  modGenes = (moduleLabels==module)
  pass_filtered = ModuleMembership_pos %>% filter(moduleLabels ==module)
  #separate the columns who has multiple protein IDs in one
  # Get their entrez ID codes
  modLLIDs = datExpr[modGenes]
  modLLIDs$cond <- rownames(modLLIDs)
  passmod <- modLLIDs %>% melt() %>%
    dplyr::rename(`Protein IDs` = variable) %>% 
    filter(`Protein IDs` %in% pass_filtered$`Protein IDs`)
  #separate the columns who has multiple protein IDs in one
  # Get their entrez ID codes
  modLLIDs = datExpr[modGenes]
  dataf = rbind(dataf, data.frame(rep(module, dim(modLLIDs)[2]),names(modLLIDs)))
  dataf_pos = rbind(dataf_pos, data.frame(rep(module, length(unique(passmod$`Protein IDs`))),passmod$`Protein IDs`))

}

colnames(dataf) <- c("moduleLabels","Protein IDs")
colnames(dataf_pos) <- c("moduleLabels","Protein IDs")

tmp3 <- right_join(proteinData %>% dplyr::select(`Protein IDs`, value, samplingTime, replicate, nutrient, genotype, `Gene names`,data), dataf_pos, by = "Protein IDs") %>%
  #caculate mean expression of each protein
  group_by(nutrient, genotype, `Protein IDs`, samplingTime, `Gene names`,data) %>%
  mutate(ave = mean(value))

tmp4 <- left_join(tmp3,ModuleMembership, by = c("Protein IDs","moduleLabels"))

##check module size 
sum <- tmp4 %>% group_by(moduleLabels) %>% 
  summarize(n=length(unique(`Protein IDs`)))
print(sum)
#make a box plot
ggplot(data=sum, aes(x=as.character(reorder(moduleLabels,n)), y=n)) +
  geom_bar(stat="identity")

modules <- unique(tmp4$moduleLabels)

  tmp4 %>% 
    filter(moduleLabels %in% c("1","2","4","5","6")) %>%
    filter(data == "normed_ratio") %>%
    filter(genotype != "spike-in" & nutrient !="N") %>%
    ggplot(aes(x=samplingTime, y=ave,group = `Protein IDs`)) +
    geom_line(aes(color = Membership),size=0.3,alpha=0.5)+
    scale_color_gradientn(colours = c("#ffea4f", "#4fff72","#4ffff0","#4f8aff","#c74fff","#c74fff","#ff0d0d"))+
    facet_wrap(genotype+nutrient~moduleLabels, scales = "free", ncol = 4)+
    theme_bw(base_size=10) +
    scale_y_log10() +
  #geom_label_repel(aes(label = `Gene names`),nudge_x = 1,na.rm = TRUE) +
    ylab("Relative level") +
    ggtitle(paste0(nutri,"_",gt,"_WGCNA")) +
    theme(panel.grid.major = element_blank(), panel.grid.minor =element_blank(),legend.position="bottom")+
    xlab("Hours post inoculation")
  
ggsave(paste0("./",nutri,"_",gt,"_","WPM_dynamic(cor>0.7).pdf"), width = 7, height = 4.5)
```

## rim15 -Carbon

###choose the soft threshold
```{r, echo = FALSE, message = FALSE, warning=FALSE}
sig_DE <- read_csv("./WGCNA/sig_DE_anova.csv")
proteinData = read_csv("./WGCNA/master_protein.csv")

nutri= "C"
gt = "rim15KO"
dt = "normed_ratio"
tmp <- sig_DE %>% filter(nutrient == nutri & genotype == gt & data == dt)

#prepare expression data table
tmp2 = proteinData %>% filter(data == dt & nutrient == nutri & genotype == gt) %>% 
  filter(`Protein IDs` %in% unique(tmp$`Protein IDs`)) %>% 
  dplyr::select(`Protein IDs`,nutrient, genotype, value, samplingTime, replicate) %>%
  unite(cond, nutrient, genotype, samplingTime, replicate) %>%
  spread(key = cond, value = value)

datExpr0 = log2(as.data.frame(t(tmp2[, -1])))
names(datExpr0) = tmp2$`Protein IDs`

dim(datExpr0)

gsg = goodSamplesGenes(datExpr0, verbose = 3);
gsg$allOK

sampleTree = hclust(dist(datExpr0), method = "average");
# Plot the sample tree: Open a graphic output window of size 12 by 9 inches
# The user should change the dimensions if the window is too large or too small.
sizeGrWindow(12,9)
#pdf(file = "Plots/sampleClustering.pdf", width = 12, height = 9);
par(cex = 0.6);
par(mar = c(0,4,2,0))
plot(sampleTree, main = "Sample clustering to detect outliers", sub="", xlab="", cex.lab = 1.5, 
     cex.axis = 1.5, cex.main = 2)

#Deal with metadata
metaData =
  as.data.frame(rownames(datExpr0)) %>%
  dplyr::rename(cond = `rownames(datExpr0)`) %>%
  separate(cond, c("nutrient","genotype","time","replicate"), remove = FALSE) %>%
  #convert samplingTime to numerics
  dplyr::select(-replicate) %>%
  mutate(time = substr(time, 2, nchar(time))) %>%
  mutate(time = as.numeric(time)) %>%
  data.frame()
  #convert nutrient, genotype into binary attributes

#select the soft-thresholding for co-expression analysis
datExpr = datExpr0 
# Choose a set of soft-thresholding powers
powers = c(c(1:10), seq(from = 12, to=30, by=2))

# Call the network topology analysis function
sft = pickSoftThreshold(datExpr, powerVector = powers, verbose = 5)
# Plot the results:
sizeGrWindow(9, 5)
par(mfrow = c(1,2));
# Scale-free topology fit index as a function of the soft-thresholding power
plot(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
     xlab="Soft Threshold (power)",ylab="Scale Free Topology Model Fit,signed R^2",type="n",
     main = paste("Scale independence"));
text(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
     labels=powers,cex=0.85,col="red");
# this line corresponds to using an R^2 cut-off of h
abline(h=0.85,col="red")
# Mean connectivity as a function of the soft-thresholding power
plot(sft$fitIndices[,1], sft$fitIndices[,5],
     xlab="Soft Threshold (power)",ylab="Mean Connectivity", type="n",
     main = paste("Mean connectivity"))
text(sft$fitIndices[,1], sft$fitIndices[,5], labels=powers, cex=0.85,col="red")
```

### one-step network construction and module detection
```{r, echo = FALSE, message = FALSE, eval = FALSE, warning=FALSE}
softPower = 18
#mergeCutHeight = 0.25
bwnet = blockwiseModules(datExpr, power = softPower, #corType = "biweight",
                       TOMType = "unsigned", minModuleSize = 5,
                       reassignThreshold = 0, mergeCutHeight = 0.25,
                       numericLabels = TRUE, pamRespectsDendro = FALSE,
                       saveTOMs = TRUE,
                       saveTOMFileBase = paste0("filtered_TOM_ratio",nutri,gt), 
                       verbose = 3)

#bwnet$colors
# open a graphics window
sizeGrWindow(12, 9)

moduleLabels = bwnet$colors
moduleColors = labels2colors(bwnet$colors)
MEs = bwnet$MEs;
geneTree = bwnet$dendrograms[[1]];
save(MEs, moduleLabels, moduleColors, geneTree, 
     file = paste0(nutri,"_",gt,"_ratio_networkConstruction-auto.RData"))
```

### Kegg annotation and visualization
```{r, echo = FALSE, message = FALSE, warning=FALSE}
#load saved co-expression clusters.
load(paste0(nutri,"_",gt,"_ratio_networkConstruction-auto.RData"))

table <- as.data.frame(moduleLabels) 
table$`Protein IDs`<- names(moduleLabels)

genotype_col<- c("#ffbc00","#7fd3cf")
names(genotype_col) <- c("WT","rim15KO")
nutrient_col <- c("#c99d4b", "#9343fa")
names(nutrient_col) <- c("C","P")
time_col <- c("#ffdbde","#fc9aa2","#fa4b59","#bd000f")
names(time_col) <- c("T00","T06","T16","T30")
rep_col <- c("#bae6c8","#44c76d","#016320")
names(rep_col) <- c("R1","R2","R3")
anno_colors <- list(nutrient = nutrient_col, genotype = genotype_col, time = time_col, replicate = rep_col)
breaksList = seq(-0.07, 0.07, by = 0.0001)

annotation <- data.frame(rownames(MEs)) %>% separate(`rownames.MEs.`, c("nutrient", "genotype", "time", "replicate"))
rownames(annotation) <- rownames(MEs)
#make heatmaps
pdf(paste0("./ME_",nutri,"_",gt,"_ratio.pdf"), width = 4, height =5)
#remove module 0 which has unsigned genes
mes <- MEs #%>% dplyr::select(-`ME0`)
pheatmap(mes, #labels_row = F,
         colorRampPalette(rev(brewer.pal(n =10, name = "RdBu")))(length(breaksList)),
         cluster_rows=T, cluster_cols=T, annotation_row= annotation, annotation_colors = anno_colors)#, 
          # annotation_col = annotation_col, main = paste0("Log2(",i,")"))
dev.off()

## Quantify traits-module association
nSamples = nrow(datExpr)
# Recalculate MEs with color labels
MEs0 = moduleEigengenes(datExpr, moduleLabels)$eigengenes
MEs = orderMEs(MEs0)
#caculate the correlation between trait time and the expression modules
moduleTraitCor = cor(MEs, metaData[,-c(1:3)], use = "p")
print(moduleTraitCor)
moduleTraitPvalue = corPvalueStudent(moduleTraitCor, nSamples)
#caculate the module membership and plot that in dynamics
geneModuleMembership = as.data.frame(cor(datExpr, MEs, use = "p"))

sizeGrWindow(10,6)
# Will display correlations and their p-values
textMatrix = paste(signif(moduleTraitCor, 2), "\n(", signif(moduleTraitPvalue, 1), ")", sep = "")
dim(textMatrix) = dim(moduleTraitCor)

### kegg annotation of interesting modules 
keggGO <- list()
keggGOresults <- list()
enrichGO <- list()
enrichGOresults <- list()

tb = NULL
tb_pos = NULL
cor_thresh = 0.7
geneModuleMembership = as.data.frame(cor(datExpr, MEs, use = "p"))
ModuleMembership_pos <- geneModuleMembership %>% mutate(`Protein IDs` = rownames(geneModuleMembership)) %>%
  melt() %>%
  #dplyr::rename(modules = variable) %>%
  #remove the ME in each module label
  dplyr::mutate(moduleLabels = substr(variable, 3, nchar(as.character(variable)))) %>% 
  dplyr::rename(Membership = value) %>%
  mutate(moduleLabels = as.numeric(moduleLabels)) %>%
  #remove genes with module membership correlation less than 0.5
  dplyr::filter(Membership > cor_thresh)

for (module in unique(moduleLabels)){
  # Select module probes
  modGenes = (moduleLabels==module)
  pass_filtered = ModuleMembership_pos %>% filter(moduleLabels ==module)
  #separate the columns who has multiple protein IDs in one
  # Get their entrez ID codes
  modLLIDs = datExpr[modGenes]
  modLLIDs$cond <- rownames(modLLIDs)
  passmod <- modLLIDs %>% melt() %>%
    dplyr::rename(`Protein IDs` = variable) %>% 
    filter(`Protein IDs` %in% pass_filtered$`Protein IDs`)
  tb = rbind(tb, data.frame(module,dim(modLLIDs)[2]))
  tb_pos = rbind(tb_pos, data.frame(module,dim(passmod)[2]))
  tmp<-bitr(unique(passmod$`Protein IDs`), "UNIPROT", "ENSEMBL", "org.Sc.sgd.db", drop = TRUE)
  keggGO[[module+1]] <- clusterProfiler::enrichKEGG(gene = tmp$ENSEMBL,
                 organism     = 'sce',
                 pvalueCutoff = 0.05)
      
  enrichGO[[module+1]] <- clusterProfiler::enrichGO(gene = tmp$UNIPROT,
                universe      = names(datExpr),
                ont = "BP",
                keyType = "UNIPROT", 
                 OrgDb     = org.Sc.sgd.db,
                 pvalueCutoff = 0.05)   
   
  keggGOresults[[module+1]] <- keggGO[[module+1]]@result %>% 
        as_tibble() %>% 
        mutate(module=module)
  
  enrichGOresults[[module+1]] <- enrichGO[[module+1]]@result %>% 
        as_tibble() %>% 
        mutate(module=module)
  }

keggGOtable <- bind_rows(keggGOresults) %>% as_tibble 
#  mutate(module=module-1)
 # filter(p.adjust < 0.1)
  
enrichGOtable <- bind_rows(enrichGOresults) %>% as_tibble %>%
  mutate(module=module-1)
 # filter(Count > 1) %>%
 # filter(p.adjust < 0.1)

#write_csv(keggGOtable, "kegg_GO_ratio_modules.csv")
#write_csv(enrichGOtable, "enrich_GO_ratio_modules.csv")

### plot KeggGO terms 
n_count = 0
tmp <- keggGOtable %>% 
  filter (module !=0) %>% 
  #remove the GO terms whose genes counts is less than 4
  filter(Count > n_count) %>%
  dplyr::select(Description, p.adjust, module) %>%
  #dplyr::filter(p.adjust < 0.05) %>% 
  spread(key = "module", value = "p.adjust") 
  

breaks <- seq(min(-log10(keggGOtable$p.adjust)), max(-log10(keggGOtable$p.adjust)), length.out = 101)
my_palette <- my_palette <- colorRampPalette(c("#ccdaff", "#002487")) (n=100)

df <- tmp[,-1]
#replace na values with 0
df[is.na(df)] <- 1
df <- -log10(df)
df[df == 0] <- NA
rownames(df) <- tmp$Description
order <- order(df[, "2"],df[,"1"])
tmp2<-df[order, c(1:2)]
#
pdf(file=paste0("kegg_map_",nutri,"_",gt,"_","ratio(n>",n_count,").pdf"),width = 7, height =6)
heatmap.2(as.matrix(tmp2), Rowv = FALSE, Colv=FALSE,trace="none", na.color = "white", scale="none", col = my_palette, breaks=breaks,margins = c(2,26),cexRow=0.7,cexCol=1,keysize=1.3,sepcolor="grey", sepwidth=c(0.05,0.05),colsep=1:ncol(tmp2),
           rowsep=1:nrow(tmp2))
dev.off()

### plot proteins behavior in each module per condition and 

#get the geneModuleMembership from previous caculation & reshape the dt to combine with the mean expression table
##or you can recalculate its here
geneModuleMembership = as.data.frame(cor(datExpr, MEs, use = "p"))

ModuleMembership <- geneModuleMembership %>% mutate(`Protein IDs` = rownames(geneModuleMembership)) %>%
  melt() %>%
  #dplyr::rename(modules = variable) %>%
  #remove the ME in each module label
  dplyr::mutate(moduleLabels = substr(variable, 3, nchar(as.character(variable)))) %>% 
  dplyr::rename(Membership = value) %>%
  mutate(moduleLabels = as.numeric(moduleLabels))

dataf = NULL
dataf_pos = NULL

for (module in unique(moduleLabels)){
  # Select module probes
  modGenes = (moduleLabels==module)
  pass_filtered = ModuleMembership_pos %>% filter(moduleLabels ==module)
  #separate the columns who has multiple protein IDs in one
  # Get their entrez ID codes
  modLLIDs = datExpr[modGenes]
  modLLIDs$cond <- rownames(modLLIDs)
  passmod <- modLLIDs %>% melt() %>%
    dplyr::rename(`Protein IDs` = variable) %>% 
    filter(`Protein IDs` %in% pass_filtered$`Protein IDs`)
  #separate the columns who has multiple protein IDs in one
  # Get their entrez ID codes
  modLLIDs = datExpr[modGenes]
  dataf = rbind(dataf, data.frame(rep(module, dim(modLLIDs)[2]),names(modLLIDs)))
  dataf_pos = rbind(dataf_pos, data.frame(rep(module, length(unique(passmod$`Protein IDs`))),passmod$`Protein IDs`))

}

colnames(dataf) <- c("moduleLabels","Protein IDs")
colnames(dataf_pos) <- c("moduleLabels","Protein IDs")

tmp3 <- right_join(proteinData %>% dplyr::select(`Protein IDs`, value, samplingTime, replicate, nutrient, genotype, `Gene names`,data), dataf_pos, by = "Protein IDs") %>%
  #caculate mean expression of each protein
  group_by(nutrient, genotype, `Protein IDs`, samplingTime, `Gene names`,data) %>%
  mutate(ave = mean(value))

tmp4 <- left_join(tmp3,ModuleMembership, by = c("Protein IDs","moduleLabels"))

##check module size 
sum <- tmp4 %>% group_by(moduleLabels) %>% 
  summarize(n=length(unique(`Protein IDs`)))
print(sum)
#make a box plot
ggplot(data=sum, aes(x=as.character(reorder(moduleLabels,n)), y=n)) +
  geom_bar(stat="identity")

modules <- unique(tmp4$moduleLabels)

  tmp4 %>% 
    filter(moduleLabels != 0) %>%
    filter(data == "normed_ratio") %>%
    filter(genotype != "spike-in" & nutrient !="N") %>%
    ggplot(aes(x=samplingTime, y=ave,group = `Protein IDs`)) +
    geom_line(aes(color = Membership),size=0.3,alpha=0.5)+
    scale_color_gradientn(colours = c("#ffea4f", "#4fff72","#4ffff0","#4f8aff","#c74fff","#c74fff","#ff0d0d"))+
    facet_wrap(genotype+nutrient~moduleLabels, scales = "free", ncol = (length(unique(modules))-1)*2)+
    theme_bw(base_size=10) +
    scale_y_log10() +
  #geom_label_repel(aes(label = `Gene names`),nudge_x = 1,na.rm = TRUE) +
    ylab("Relative level") +
    ggtitle(paste0(nutri,"_",gt,"_WGCNA")) +
    theme(panel.grid.major = element_blank(), panel.grid.minor =element_blank(),legend.position="bottom")+
    xlab("Hours post inoculation")
  
ggsave(paste0("./",nutri,"_",gt,"_","WPM_dynamic(cor>0.7).pdf"), width = 7, height = 4.5)
```

## WT -Pi

###choose the soft threshold
```{r, echo = FALSE, message = FALSE, warning=FALSE}
sig_DE <- read_csv("./WGCNA/sig_DE_anova.csv")
proteinData = read_csv("./WGCNA/master_protein.csv")

nutri= "P"
gt = "WT"
dt = "normed_ratio"
tmp <- sig_DE %>% filter(nutrient == nutri & genotype == gt & data == dt)

#prepare expression data table
tmp2 = proteinData %>% filter(data == dt & nutrient == nutri & genotype == gt) %>% 
  filter(`Protein IDs` %in% unique(tmp$`Protein IDs`)) %>% 
  dplyr::select(`Protein IDs`,nutrient, genotype, value, samplingTime, replicate) %>%
  unite(cond, nutrient, genotype, samplingTime, replicate) %>%
  spread(key = cond, value = value)

datExpr0 = log2(as.data.frame(t(tmp2[, -1])))
names(datExpr0) = tmp2$`Protein IDs`

dim(datExpr0)

gsg = goodSamplesGenes(datExpr0, verbose = 3);
gsg$allOK

sampleTree = hclust(dist(datExpr0), method = "average");
# Plot the sample tree: Open a graphic output window of size 12 by 9 inches
# The user should change the dimensions if the window is too large or too small.
sizeGrWindow(12,9)
#pdf(file = "Plots/sampleClustering.pdf", width = 12, height = 9);
par(cex = 0.6);
par(mar = c(0,4,2,0))
plot(sampleTree, main = "Sample clustering to detect outliers", sub="", xlab="", cex.lab = 1.5, 
     cex.axis = 1.5, cex.main = 2)

#Deal with metadata
metaData =
  as.data.frame(rownames(datExpr0)) %>%
  dplyr::rename(cond = `rownames(datExpr0)`) %>%
  separate(cond, c("nutrient","genotype","time","replicate"), remove = FALSE) %>%
  #convert samplingTime to numerics
  dplyr::select(-replicate) %>%
  mutate(time = substr(time, 2, nchar(time))) %>%
  mutate(time = as.numeric(time)) %>%
  data.frame()
  #convert nutrient, genotype into binary attributes

#select the soft-thresholding for co-expression analysis
datExpr = datExpr0 
# Choose a set of soft-thresholding powers
powers = c(c(1:10), seq(from = 12, to=30, by=2))

# Call the network topology analysis function
sft = pickSoftThreshold(datExpr, powerVector = powers, verbose = 5)
# Plot the results:
sizeGrWindow(9, 5)
par(mfrow = c(1,2));
# Scale-free topology fit index as a function of the soft-thresholding power
plot(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
     xlab="Soft Threshold (power)",ylab="Scale Free Topology Model Fit,signed R^2",type="n",
     main = paste("Scale independence"));
text(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
     labels=powers,cex=0.85,col="red");
# this line corresponds to using an R^2 cut-off of h
abline(h=0.85,col="red")
# Mean connectivity as a function of the soft-thresholding power
plot(sft$fitIndices[,1], sft$fitIndices[,5],
     xlab="Soft Threshold (power)",ylab="Mean Connectivity", type="n",
     main = paste("Mean connectivity"))
text(sft$fitIndices[,1], sft$fitIndices[,5], labels=powers, cex=0.85,col="red")
```

### one-step network construction and module detection
```{r, echo = FALSE, message = FALSE, eval = FALSE, warning=FALSE}
softPower = 24
#mergeCutHeight = 0.25
bwnet = blockwiseModules(datExpr, power = softPower, #corType = "biweight",
                       TOMType = "unsigned", minModuleSize = 5,
                       reassignThreshold = 0, mergeCutHeight = 0.25,
                       numericLabels = TRUE, pamRespectsDendro = FALSE,
                       saveTOMs = TRUE,
                       saveTOMFileBase = paste0("filtered_TOM_ratio",nutri,gt), 
                       verbose = 3)

#bwnet$colors
# open a graphics window
sizeGrWindow(12, 9)

moduleLabels = bwnet$colors
moduleColors = labels2colors(bwnet$colors)
MEs = bwnet$MEs;
geneTree = bwnet$dendrograms[[1]];
save(MEs, moduleLabels, moduleColors, geneTree, 
     file = paste0(nutri,"_",gt,"_ratio_networkConstruction-auto.RData"))
```

### Kegg annotation and visualization
```{r, echo = FALSE, message = FALSE, warning=FALSE}
#load saved co-expression clusters.
load(paste0(nutri,"_",gt,"_ratio_networkConstruction-auto.RData"))

table <- as.data.frame(moduleLabels) 
table$`Protein IDs`<- names(moduleLabels)

genotype_col<- c("#ffbc00","#7fd3cf")
names(genotype_col) <- c("WT","rim15KO")
nutrient_col <- c("#c99d4b", "#9343fa")
names(nutrient_col) <- c("C","P")
time_col <- c("#ffdbde","#fc9aa2","#fa4b59","#bd000f")
names(time_col) <- c("T00","T06","T16","T30")
rep_col <- c("#bae6c8","#44c76d","#016320")
names(rep_col) <- c("R1","R2","R3")
anno_colors <- list(nutrient = nutrient_col, genotype = genotype_col, time = time_col, replicate = rep_col)
breaksList = seq(-0.07, 0.07, by = 0.0001)

annotation <- data.frame(rownames(MEs)) %>% separate(`rownames.MEs.`, c("nutrient", "genotype", "time", "replicate"))
rownames(annotation) <- rownames(MEs)
#make heatmaps
pdf(paste0("./ME_",nutri,"_",gt,"_ratio.pdf"), width = 4, height =5)
#remove module 0 which has unsigned genes
mes <- MEs #%>% dplyr::select(-`ME0`)
pheatmap(mes, #labels_row = F,
         colorRampPalette(rev(brewer.pal(n =10, name = "RdBu")))(length(breaksList)),
         cluster_rows=T, cluster_cols=T, annotation_row= annotation, annotation_colors = anno_colors)#, 
          # annotation_col = annotation_col, main = paste0("Log2(",i,")"))
dev.off()

## Quantify traits-module association
nSamples = nrow(datExpr)
# Recalculate MEs with color labels
MEs0 = moduleEigengenes(datExpr, moduleLabels)$eigengenes
MEs = orderMEs(MEs0)
#caculate the correlation between trait time and the expression modules
moduleTraitCor = cor(MEs, metaData[,-c(1:3)], use = "p")
print(moduleTraitCor)
moduleTraitPvalue = corPvalueStudent(moduleTraitCor, nSamples)
#caculate the module membership and plot that in dynamics
geneModuleMembership = as.data.frame(cor(datExpr, MEs, use = "p"))

sizeGrWindow(10,6)
# Will display correlations and their p-values
textMatrix = paste(signif(moduleTraitCor, 2), "\n(", signif(moduleTraitPvalue, 1), ")", sep = "")
dim(textMatrix) = dim(moduleTraitCor)

### kegg annotation of interesting modules 
keggGO <- list()
keggGOresults <- list()
enrichGO <- list()
enrichGOresults <- list()

tb = NULL
tb_pos = NULL
cor_thresh = 0.7
geneModuleMembership = as.data.frame(cor(datExpr, MEs, use = "p"))
ModuleMembership_pos <- geneModuleMembership %>% mutate(`Protein IDs` = rownames(geneModuleMembership)) %>%
  melt() %>%
  #dplyr::rename(modules = variable) %>%
  #remove the ME in each module label
  dplyr::mutate(moduleLabels = substr(variable, 3, nchar(as.character(variable)))) %>% 
  dplyr::rename(Membership = value) %>%
  mutate(moduleLabels = as.numeric(moduleLabels)) %>%
  #remove genes with module membership correlation less than 0.5
  dplyr::filter(Membership > cor_thresh)

for (module in unique(moduleLabels)){
  # Select module probes
  modGenes = (moduleLabels==module)
  pass_filtered = ModuleMembership_pos %>% filter(moduleLabels ==module)
  #separate the columns who has multiple protein IDs in one
  # Get their entrez ID codes
  modLLIDs = datExpr[modGenes]
  modLLIDs$cond <- rownames(modLLIDs)
  passmod <- modLLIDs %>% melt() %>%
    dplyr::rename(`Protein IDs` = variable) %>% 
    filter(`Protein IDs` %in% pass_filtered$`Protein IDs`)
  tb = rbind(tb, data.frame(module,dim(modLLIDs)[2]))
  tb_pos = rbind(tb_pos, data.frame(module,dim(passmod)[2]))
  tmp<-bitr(unique(passmod$`Protein IDs`), "UNIPROT", "ENSEMBL", "org.Sc.sgd.db", drop = TRUE)
  keggGO[[module+1]] <- clusterProfiler::enrichKEGG(gene = tmp$ENSEMBL,
                 organism     = 'sce',
                 pvalueCutoff = 0.05)
      
  enrichGO[[module+1]] <- clusterProfiler::enrichGO(gene = tmp$UNIPROT,
                universe      = names(datExpr),
                ont = "BP",
                keyType = "UNIPROT", 
                 OrgDb     = org.Sc.sgd.db,
                 pvalueCutoff = 0.05)   
   
  keggGOresults[[module+1]] <- keggGO[[module+1]]@result %>% 
        as_tibble() %>% 
        mutate(module=module)
  
  enrichGOresults[[module+1]] <- enrichGO[[module+1]]@result %>% 
        as_tibble() %>% 
        mutate(module=module)
  }

keggGOtable <- bind_rows(keggGOresults) %>% as_tibble 
#  mutate(module=module-1)
 # filter(p.adjust < 0.1)
  
enrichGOtable <- bind_rows(enrichGOresults) %>% as_tibble %>%
  mutate(module=module-1)
 # filter(Count > 1) %>%
 # filter(p.adjust < 0.1)

#write_csv(keggGOtable, "kegg_GO_ratio_modules.csv")
#write_csv(enrichGOtable, "enrich_GO_ratio_modules.csv")

### plot KeggGO terms 
n_count = 0
tmp <- keggGOtable %>% 
  filter (module !=0) %>% 
  #remove the GO terms whose genes counts is less than 4
  filter(Count > n_count) %>%
  dplyr::select(Description, p.adjust, module) %>%
  #dplyr::filter(p.adjust < 0.05) %>% 
  spread(key = "module", value = "p.adjust") 
  

breaks <- seq(min(-log10(keggGOtable$p.adjust)), max(-log10(keggGOtable$p.adjust)), length.out = 101)
my_palette <- my_palette <- colorRampPalette(c("#ccdaff", "#002487")) (n=100)

df <- tmp[,-1]
#replace na values with 0
df[is.na(df)] <- 1
df <- -log10(df)
df[df == 0] <- NA
rownames(df) <- tmp$Description
order <- order(df[, "2"],df[,"1"])
tmp2<-df[order, c(1:2)]
#
pdf(file=paste0("kegg_map_",nutri,"_",gt,"_","ratio(n>",n_count,").pdf"),width = 7, height =6)
heatmap.2(as.matrix(tmp2), Rowv = FALSE, Colv=FALSE,trace="none", na.color = "white", scale="none", col = my_palette, breaks=breaks,margins = c(2,26),cexRow=0.7,cexCol=1,keysize=1.3,sepcolor="grey", sepwidth=c(0.05,0.05),colsep=1:ncol(tmp2),
           rowsep=1:nrow(tmp2))
dev.off()

### plot proteins behavior in each module per condition and 

#get the geneModuleMembership from previous caculation & reshape the dt to combine with the mean expression table
##or you can recalculate its here
geneModuleMembership = as.data.frame(cor(datExpr, MEs, use = "p"))

ModuleMembership <- geneModuleMembership %>% mutate(`Protein IDs` = rownames(geneModuleMembership)) %>%
  melt() %>%
  #dplyr::rename(modules = variable) %>%
  #remove the ME in each module label
  dplyr::mutate(moduleLabels = substr(variable, 3, nchar(as.character(variable)))) %>% 
  dplyr::rename(Membership = value) %>%
  mutate(moduleLabels = as.numeric(moduleLabels))

dataf = NULL
dataf_pos = NULL

for (module in unique(moduleLabels)){
  # Select module probes
  modGenes = (moduleLabels==module)
  pass_filtered = ModuleMembership_pos %>% filter(moduleLabels ==module)
  #separate the columns who has multiple protein IDs in one
  # Get their entrez ID codes
  modLLIDs = datExpr[modGenes]
  modLLIDs$cond <- rownames(modLLIDs)
  passmod <- modLLIDs %>% melt() %>%
    dplyr::rename(`Protein IDs` = variable) %>% 
    filter(`Protein IDs` %in% pass_filtered$`Protein IDs`)
  #separate the columns who has multiple protein IDs in one
  # Get their entrez ID codes
  modLLIDs = datExpr[modGenes]
  dataf = rbind(dataf, data.frame(rep(module, dim(modLLIDs)[2]),names(modLLIDs)))
  dataf_pos = rbind(dataf_pos, data.frame(rep(module, length(unique(passmod$`Protein IDs`))),passmod$`Protein IDs`))

}

colnames(dataf) <- c("moduleLabels","Protein IDs")
colnames(dataf_pos) <- c("moduleLabels","Protein IDs")

tmp3 <- right_join(proteinData %>% dplyr::select(`Protein IDs`, value, samplingTime, replicate, nutrient, genotype, `Gene names`,data), dataf_pos, by = "Protein IDs") %>%
  #caculate mean expression of each protein
  group_by(nutrient, genotype, `Protein IDs`, samplingTime, `Gene names`,data) %>%
  mutate(ave = mean(value))

tmp4 <- left_join(tmp3,ModuleMembership, by = c("Protein IDs","moduleLabels"))

##check module size 
sum <- tmp4 %>% group_by(moduleLabels) %>% 
  summarize(n=length(unique(`Protein IDs`)))
print(sum)
#make a box plot
ggplot(data=sum, aes(x=as.character(reorder(moduleLabels,n)), y=n)) +
  geom_bar(stat="identity")

modules <- unique(tmp4$moduleLabels)

  tmp4 %>% 
    filter(moduleLabels != 0) %>%
    filter(data == "normed_ratio") %>%
    filter(genotype != "spike-in" & nutrient !="N") %>%
    ggplot(aes(x=samplingTime, y=ave,group = `Protein IDs`)) +
    geom_line(aes(color = Membership),size=0.3,alpha=0.5)+
    scale_color_gradientn(colours = c("#ffea4f", "#4fff72","#4ffff0","#4f8aff","#c74fff","#c74fff","#ff0d0d"))+
    facet_wrap(genotype+nutrient~moduleLabels, scales = "free", ncol = (length(unique(modules))-1)*2)+
    theme_bw(base_size=10) +
    scale_y_log10() +
  #geom_label_repel(aes(label = `Gene names`),nudge_x = 1,na.rm = TRUE) +
    ylab("Relative level") +
    ggtitle(paste0(nutri,"_",gt,"_WGCNA")) +
    theme(panel.grid.major = element_blank(), panel.grid.minor =element_blank(),legend.position="bottom")+
    xlab("Hours post inoculation")
  
ggsave(paste0("./",nutri,"_",gt,"_","WPM_dynamic(cor>0.7).pdf"), width = 7, height = 4.5)
```

## rim15KO -Pi

###choose the soft threshold
```{r, echo = FALSE, message = FALSE, warning=FALSE}
sig_DE <- read_csv("./WGCNA/sig_DE_anova.csv")
proteinData = read_csv("./WGCNA/master_protein.csv")

nutri= "P"
gt = "rim15KO"
dt = "normed_ratio"
tmp <- sig_DE %>% filter(nutrient == nutri & genotype == gt & data == dt)

#prepare expression data table
tmp2 = proteinData %>% filter(data == dt & nutrient == nutri & genotype == gt) %>% 
  filter(`Protein IDs` %in% unique(tmp$`Protein IDs`)) %>% 
  dplyr::select(`Protein IDs`,nutrient, genotype, value, samplingTime, replicate) %>%
  unite(cond, nutrient, genotype, samplingTime, replicate) %>%
  spread(key = cond, value = value)

datExpr0 = log2(as.data.frame(t(tmp2[, -1])))
names(datExpr0) = tmp2$`Protein IDs`

dim(datExpr0)

gsg = goodSamplesGenes(datExpr0, verbose = 3);
gsg$allOK

sampleTree = hclust(dist(datExpr0), method = "average");
# Plot the sample tree: Open a graphic output window of size 12 by 9 inches
# The user should change the dimensions if the window is too large or too small.
sizeGrWindow(12,9)
#pdf(file = "Plots/sampleClustering.pdf", width = 12, height = 9);
par(cex = 0.6);
par(mar = c(0,4,2,0))
plot(sampleTree, main = "Sample clustering to detect outliers", sub="", xlab="", cex.lab = 1.5, 
     cex.axis = 1.5, cex.main = 2)

#Deal with metadata
metaData =
  as.data.frame(rownames(datExpr0)) %>%
  dplyr::rename(cond = `rownames(datExpr0)`) %>%
  separate(cond, c("nutrient","genotype","time","replicate"), remove = FALSE) %>%
  #convert samplingTime to numerics
  dplyr::select(-replicate) %>%
  mutate(time = substr(time, 2, nchar(time))) %>%
  mutate(time = as.numeric(time)) %>%
  data.frame()
  #convert nutrient, genotype into binary attributes

#select the soft-thresholding for co-expression analysis
datExpr = datExpr0 
# Choose a set of soft-thresholding powers
powers = c(c(1:10), seq(from = 12, to=30, by=2))

# Call the network topology analysis function
sft = pickSoftThreshold(datExpr, powerVector = powers, verbose = 5)
# Plot the results:
sizeGrWindow(9, 5)
par(mfrow = c(1,2));
# Scale-free topology fit index as a function of the soft-thresholding power
plot(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
     xlab="Soft Threshold (power)",ylab="Scale Free Topology Model Fit,signed R^2",type="n",
     main = paste("Scale independence"));
text(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
     labels=powers,cex=0.85,col="red");
# this line corresponds to using an R^2 cut-off of h
abline(h=0.85,col="red")
# Mean connectivity as a function of the soft-thresholding power
plot(sft$fitIndices[,1], sft$fitIndices[,5],
     xlab="Soft Threshold (power)",ylab="Mean Connectivity", type="n",
     main = paste("Mean connectivity"))
text(sft$fitIndices[,1], sft$fitIndices[,5], labels=powers, cex=0.85,col="red")
```

### one-step network construction and module detection
```{r, echo = FALSE, message = FALSE, eval = FALSE,warning=FALSE}
softPower = 18
#mergeCutHeight = 0.25
bwnet = blockwiseModules(datExpr, power = softPower, #corType = "biweight",
                       TOMType = "unsigned", minModuleSize = 5,
                       reassignThreshold = 0, mergeCutHeight = 0.25,
                       numericLabels = TRUE, pamRespectsDendro = FALSE,
                       saveTOMs = TRUE,
                       saveTOMFileBase = paste0("filtered_TOM_ratio",nutri,gt), 
                       verbose = 3)
#bwnet$colors
# open a graphics window
sizeGrWindow(12, 9)

moduleLabels = bwnet$colors
moduleColors = labels2colors(bwnet$colors)
MEs = bwnet$MEs;
geneTree = bwnet$dendrograms[[1]];
save(MEs, moduleLabels, moduleColors, geneTree, 
     file = paste0(nutri,"_",gt,"_ratio_networkConstruction-auto.RData"))
```

### Kegg annotation and visualization
```{r, echo = FALSE, message = FALSE, warning=FALSE}
#load saved co-expression clusters.
load(paste0(nutri,"_",gt,"_ratio_networkConstruction-auto.RData"))

table <- as.data.frame(moduleLabels) 
table$`Protein IDs`<- names(moduleLabels)

genotype_col<- c("#ffbc00","#7fd3cf")
names(genotype_col) <- c("WT","rim15KO")
nutrient_col <- c("#c99d4b", "#9343fa")
names(nutrient_col) <- c("C","P")
time_col <- c("#ffdbde","#fc9aa2","#fa4b59","#bd000f")
names(time_col) <- c("T00","T06","T16","T30")
rep_col <- c("#bae6c8","#44c76d","#016320")
names(rep_col) <- c("R1","R2","R3")
anno_colors <- list(nutrient = nutrient_col, genotype = genotype_col, time = time_col, replicate = rep_col)
breaksList = seq(-0.07, 0.07, by = 0.0001)

annotation <- data.frame(rownames(MEs)) %>% separate(`rownames.MEs.`, c("nutrient", "genotype", "time", "replicate"))
rownames(annotation) <- rownames(MEs)
#make heatmaps
pdf(paste0("./ME_",nutri,"_",gt,"_ratio.pdf"), width = 4, height =5)
#remove module 0 which has unsigned genes
mes <- MEs #%>% dplyr::select(-`ME0`)
pheatmap(mes, #labels_row = F,
         colorRampPalette(rev(brewer.pal(n =10, name = "RdBu")))(length(breaksList)),
         cluster_rows=T, cluster_cols=T, annotation_row= annotation, annotation_colors = anno_colors)#, 
          # annotation_col = annotation_col, main = paste0("Log2(",i,")"))
dev.off()

## Quantify traits-module association
nSamples = nrow(datExpr)
# Recalculate MEs with color labels
MEs0 = moduleEigengenes(datExpr, moduleLabels)$eigengenes
MEs = orderMEs(MEs0)
#caculate the correlation between trait time and the expression modules
moduleTraitCor = cor(MEs, metaData[,-c(1:3)], use = "p")
print(moduleTraitCor)
moduleTraitPvalue = corPvalueStudent(moduleTraitCor, nSamples)
#caculate the module membership and plot that in dynamics
geneModuleMembership = as.data.frame(cor(datExpr, MEs, use = "p"))

sizeGrWindow(10,6)
# Will display correlations and their p-values
textMatrix = paste(signif(moduleTraitCor, 2), "\n(", signif(moduleTraitPvalue, 1), ")", sep = "")
dim(textMatrix) = dim(moduleTraitCor)

### kegg annotation of interesting modules 
keggGO <- list()
keggGOresults <- list()
enrichGO <- list()
enrichGOresults <- list()

tb = NULL
tb_pos = NULL
cor_thresh = 0.7
geneModuleMembership = as.data.frame(cor(datExpr, MEs, use = "p"))
ModuleMembership_pos <- geneModuleMembership %>% mutate(`Protein IDs` = rownames(geneModuleMembership)) %>%
  melt() %>%
  #dplyr::rename(modules = variable) %>%
  #remove the ME in each module label
  dplyr::mutate(moduleLabels = substr(variable, 3, nchar(as.character(variable)))) %>% 
  dplyr::rename(Membership = value) %>%
  mutate(moduleLabels = as.numeric(moduleLabels)) %>%
  #remove genes with module membership correlation less than 0.5
  dplyr::filter(Membership > cor_thresh)

for (module in unique(moduleLabels)){
  # Select module probes
  modGenes = (moduleLabels==module)
  pass_filtered = ModuleMembership_pos %>% filter(moduleLabels ==module)
  #separate the columns who has multiple protein IDs in one
  # Get their entrez ID codes
  modLLIDs = datExpr[modGenes]
  modLLIDs$cond <- rownames(modLLIDs)
  passmod <- modLLIDs %>% melt() %>%
    dplyr::rename(`Protein IDs` = variable) %>% 
    filter(`Protein IDs` %in% pass_filtered$`Protein IDs`)
  tb = rbind(tb, data.frame(module,dim(modLLIDs)[2]))
  tb_pos = rbind(tb_pos, data.frame(module,dim(passmod)[2]))
  tmp<-bitr(unique(passmod$`Protein IDs`), "UNIPROT", "ENSEMBL", "org.Sc.sgd.db", drop = TRUE)
  keggGO[[module+1]] <- clusterProfiler::enrichKEGG(gene = tmp$ENSEMBL,
                 organism     = 'sce',
                 pvalueCutoff = 0.05)
      
  enrichGO[[module+1]] <- clusterProfiler::enrichGO(gene = tmp$UNIPROT,
                universe      = names(datExpr),
                ont = "BP",
                keyType = "UNIPROT", 
                 OrgDb     = org.Sc.sgd.db,
                 pvalueCutoff = 0.05)   
   
  keggGOresults[[module+1]] <- keggGO[[module+1]]@result %>% 
        as_tibble() %>% 
        mutate(module=module)
  
  enrichGOresults[[module+1]] <- enrichGO[[module+1]]@result %>% 
        as_tibble() %>% 
        mutate(module=module)
  }

keggGOtable <- bind_rows(keggGOresults) %>% as_tibble 
#  mutate(module=module-1)
 # filter(p.adjust < 0.1)
  
enrichGOtable <- bind_rows(enrichGOresults) %>% as_tibble %>%
  mutate(module=module-1)
 # filter(Count > 1) %>%
 # filter(p.adjust < 0.1)

#write_csv(keggGOtable, "kegg_GO_ratio_modules.csv")
#write_csv(enrichGOtable, "enrich_GO_ratio_modules.csv")

### plot KeggGO terms 
n_count = 0
tmp <- keggGOtable %>% 
  filter (module !=0) %>% 
  #remove the GO terms whose genes counts is less than 4
  filter(Count > n_count) %>%
  dplyr::select(Description, p.adjust, module) %>%
  #dplyr::filter(p.adjust < 0.05) %>% 
  spread(key = "module", value = "p.adjust") 
  

breaks <- seq(min(-log10(keggGOtable$p.adjust)), max(-log10(keggGOtable$p.adjust)), length.out = 101)
my_palette <- my_palette <- colorRampPalette(c("#ccdaff", "#002487")) (n=100)

df <- tmp[,-1]
#replace na values with 0
df[is.na(df)] <- 1
df <- -log10(df)
df[df == 0] <- NA
rownames(df) <- tmp$Description
order <- order(df[, "2"],df[,"1"])
tmp2<-df[order, c(1:2)]
#
pdf(file=paste0("kegg_map_",nutri,"_",gt,"_","ratio(n>",n_count,").pdf"),width = 7, height =6)
heatmap.2(as.matrix(tmp2), Rowv = FALSE, Colv=FALSE,trace="none", na.color = "white", scale="none", col = my_palette, breaks=breaks,margins = c(2,26),cexRow=0.7,cexCol=1,keysize=1.3,sepcolor="grey", sepwidth=c(0.05,0.05),colsep=1:ncol(tmp2),
           rowsep=1:nrow(tmp2))
dev.off()

### plot proteins behavior in each module per condition and 

#get the geneModuleMembership from previous caculation & reshape the dt to combine with the mean expression table
##or you can recalculate its here
geneModuleMembership = as.data.frame(cor(datExpr, MEs, use = "p"))

ModuleMembership <- geneModuleMembership %>% mutate(`Protein IDs` = rownames(geneModuleMembership)) %>%
  melt() %>%
  #dplyr::rename(modules = variable) %>%
  #remove the ME in each module label
  dplyr::mutate(moduleLabels = substr(variable, 3, nchar(as.character(variable)))) %>% 
  dplyr::rename(Membership = value) %>%
  mutate(moduleLabels = as.numeric(moduleLabels))

dataf = NULL
dataf_pos = NULL

for (module in unique(moduleLabels)){
  # Select module probes
  modGenes = (moduleLabels==module)
  pass_filtered = ModuleMembership_pos %>% filter(moduleLabels ==module)
  #separate the columns who has multiple protein IDs in one
  # Get their entrez ID codes
  modLLIDs = datExpr[modGenes]
  modLLIDs$cond <- rownames(modLLIDs)
  passmod <- modLLIDs %>% melt() %>%
    dplyr::rename(`Protein IDs` = variable) %>% 
    filter(`Protein IDs` %in% pass_filtered$`Protein IDs`)
  #separate the columns who has multiple protein IDs in one
  # Get their entrez ID codes
  modLLIDs = datExpr[modGenes]
  dataf = rbind(dataf, data.frame(rep(module, dim(modLLIDs)[2]),names(modLLIDs)))
  dataf_pos = rbind(dataf_pos, data.frame(rep(module, length(unique(passmod$`Protein IDs`))),passmod$`Protein IDs`))

}

colnames(dataf) <- c("moduleLabels","Protein IDs")
colnames(dataf_pos) <- c("moduleLabels","Protein IDs")

tmp3 <- right_join(proteinData %>% dplyr::select(`Protein IDs`, value, samplingTime, replicate, nutrient, genotype, `Gene names`,data), dataf_pos, by = "Protein IDs") %>%
  #caculate mean expression of each protein
  group_by(nutrient, genotype, `Protein IDs`, samplingTime, `Gene names`,data) %>%
  mutate(ave = mean(value))

tmp4 <- left_join(tmp3,ModuleMembership, by = c("Protein IDs","moduleLabels"))

##check module size 
sum <- tmp4 %>% group_by(moduleLabels) %>% 
  summarize(n=length(unique(`Protein IDs`)))
print(sum)
#make a box plot
ggplot(data=sum, aes(x=as.character(reorder(moduleLabels,n)), y=n)) +
  geom_bar(stat="identity")

modules <- unique(tmp4$moduleLabels)

  tmp4 %>% 
    filter(moduleLabels != 0) %>%
    filter(data == "normed_ratio") %>%
    filter(genotype != "spike-in" & nutrient !="N") %>%
    ggplot(aes(x=samplingTime, y=ave,group = `Protein IDs`)) +
    geom_line(aes(color = Membership),size=0.3,alpha=0.5)+
    scale_color_gradientn(colours = c("#ffea4f", "#4fff72","#4ffff0","#4f8aff","#c74fff","#c74fff","#ff0d0d"))+
    facet_wrap(genotype+nutrient~moduleLabels, scales = "free", ncol = (length(unique(modules))-1)*2)+
    theme_bw(base_size=10) +
    scale_y_log10() +
  #geom_label_repel(aes(label = `Gene names`),nudge_x = 1,na.rm = TRUE) +
    ylab("Relative level") +
    ggtitle(paste0(nutri,"_",gt,"_WGCNA")) +
    theme(panel.grid.major = element_blank(), panel.grid.minor =element_blank(),legend.position="bottom")+
    xlab("Hours post inoculation")
  
ggsave(paste0("./",nutri,"_",gt,"_","WPM_dynamic(cor>0.7).pdf"), width = 7, height = 4.5)
```

## Consensus motif in -C and -Pi for WT
```{r}
```

## Consensus motif in -C and -Pi for rim15
```{r}
```

## Consensus motif between WT and rim15
```{r}
```


